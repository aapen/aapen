* Quality of Life
** TODO Make codespaces work
- [ ] Question: can the codespaces config require an aarch64 container?
- [ ] Set up container with tools: zig (pin to a release?), qemu, gdb-mutliarch
** TODO Discuss device tree & DTBs with Russ
*** Notes and references
https://github.com/devicetree-org/devicetree-specification

** DONE Figure out how to have the system under test exit QEMU
This will be useful for writing tests
*** Notes & References
The technique needed is "semihosting". This allows certain traps to
act as a syscall to communicate with the emulator.

We can use this to tell QEMU to exit with some particular status code.

It is also possible to use this as another text channel, though we
probably don't want to use it that way. That channel and any messages
sent on it would never be visible when using real hardware.

According to
https://www.qemu.org/docs/master/about/emulation.html#semihosting, the
instruction used differs per ARM processor. Our target devices all use
Cortex-A series processors in 64-bit mode, so we use ~HLT #0xF000~ to
invoke the semihosting interface.

Before executing the HLT, we put the "operation number" in W0 and a
single parameter number in X1. After the HLT, X0 holds the return code
from the semihosted call, although we mostly want to exit QEMU so
return is not a concern.

Per https://www.qemu.org/docs/master/about/emulation.html#semihosting,
we can use ~SYS_EXIT~ (0x18) as the operation number. The parameter in
X1 points to a 2 a struct of 2 u64's which indicates /why/ the exit is
taken. We will use ~ADP_Stopped_ApplicationExit~ (0x20026) for
field 1. Field 2 will have the exit status code we want to
signal. QEMU will then use that status code as it's own exit code, so
the parent process can see what the kernel wanted to indicate.

QEMU docs on semihosting: https://www.qemu.org/docs/master/about/emulation.html#semihosting

ARM docs on the semihosting interface: https://github.com/ARM-software/abi-aa/blob/main/semihosting/semihosting.rst
** DONE Use the old chainboot kernel & jtag boot from https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials
Stage 1 on the SD card
Stage 2 (the chainboot) downloaded automatically by minipush.rb
Stage 3 (the real kernel) loaded via gdb (connected via openocd)
* Milestone: Run a kernel
** DONE Perform "Hello world" as RPi3 under QEMU
** DONE Perform "Hello world" on RPi3 hardware
** TODO Prepare for "real" operating modde
- [ ] copy kernel to high memory
- [ ] Set up translation tables
- [ ] Reserve the device pages, mark them in TT properly
- [ ] Mark kernel text pages as RX, kernel data (GOT, stack, BSS) as RW/NX
- [ ] Set up interrupt handler tables, point everything to a "panic" that dumps state on UART
- [ ] Transition from EL2 to EL1
** TODO Perform "Hello world" on RPi4 hardware
* Milestone: Interact
** DONE Read from serial input on RPi3 under QEMU
Read and echo characters.
Polling is fine.
This will actually be the host machine's keyboard in a terminal, proxied to the PL011 UART in the emulated device.
** TODO Read from serial input on RPi3
Read and echo characters.
Polling is fine.
** TODO Read from serial input on RPi4
** TODO Read from USB keyboard input on RPi3 & RPi4 hardware
*** Notes and references

Read and echo characters.
** TODO Switch to using interrupts instead of polling
* Milestone: Get Ziggy
** DONE Replace C stubs with equivalent Zig
** DONE Use Zig cross-compilation instead of crosstools
* Milestone: Show the World
** TODO Read from USB keyboard on RPi 400
** TODO Initialize video system on RPi 400
HDMI output, videocode
** TODO Clear screen on RPi 400
** TODO Display a text cursor
** TODO Write characters to the screen
** TODO Echo typed characters to the screen
** TODO Make panics write to the screen
* Milestone: Set Forth
* Open Questions
** Should we use device tree?
** Should we replace the jtag boot & chainloader with our own?
